<script src="https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.0/axios.min.js"></script>

<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <!-- Add necessary dependencies, styles, and scripts -->
</head>
<body>
    <style>
        .chessboard {
            background-image: url("/images/bancotuong.jpg");
            width: 850px;
            height: 850px;
            position: absolute;
        }
    
        .chessnode {
            position: absolute;
            width: 50px;
            height: 50px;
        }
    
        .chessimgnode {
            width: 50px;
            height: 50px;
        }
    </style>
    <div id="app" style="min-height:900px">
        
        <div class="chessboard">
            <div v-for="item in chessNode" class="chessnode"
                    v-on:dragstart="dragStart"
                    v-on:dragend="dragEnd"
                    :id="item.id" :style="{ display: item.visible, top: item.top + 'px', left: item.left + 'px' }">
                    <img :src="'/images' + item.src" class="chessimgnode" />
            </div>
        </div>
    </div>
</body>
</html>
<script th:inline="javascript">
    var a = 1;
        if(a == 1) {
        console.log('true');
        } else {
        console.log('false');
        }
    var matrix = [];
    var app = new Vue({
        el: "#app",
        data: {
            chessNode: [],
            msg: "test message",
            top:0,
            left:0
        },
        methods: {
            getChessNode() {
                axios({
                    method: 'GET',
                    url: '/api/getChessBoard',
                    responseType: 'Json'
                }).then((response) =>  {
                    this.chessNode = response.data.chessNodeList;
                    this.matrix = response.data.matrix; // Gán dữ liệu ma trận từ API
                    console.log(this.matrix);
                    console.log(this.chessNode);
                }).catch((error) => {
                    console.error('Error fetching chess board data:', error);
                });
            },
            checkIndex(top, left){
                var obj = {};
                for (var i = 0; i < matrix.length;i++){
                    for(var j=0;j< matrix[i].length;j++){
                        if (Math.abs(matrix[i][j].top - top)<20 && Math.abs(matrix[i][j].left - left) < 20){
                            obj.i = i;
                            obj.j = j;
                            return obj;
                        }
                    }
                }
                return null;
            },
            dragStart(event){
                var id = event.currentTarget.id;
                this.top = event.clientY;
                this.left = event.clientX;
            },
            dragEnd(event){
                var clientXStart =  event.currentTarget.offsetLeft;
                var clientYStart =  event.currentTarget.offsetTop;

                var clientX = event.clientX - this.left + event.currentTarget.offsetLeft;
                var clientY = event.clientY - this.top + event.currentTarget.offsetTop;
                clientX = Math.abs(clientX);
                clientY = Math.abs(clientY);
                var objEnd = this.checkIndex(clientY, clientX);
                var objStart = this.checkIndex(clientYStart, clientXStart);

                if (objEnd == null){
                   return;
                }
                

                if (event.currentTarget.id.indexOf("ma") >=0 && (Math.abs(objStart.i - objEnd.i) == 1 && Math.abs(objStart.j - objEnd.j) == 2) ||
                    (Math.abs(objStart.i - objEnd.i) == 2 && Math.abs(objStart.j - objEnd.j) == 1)){

                    if (Math.abs(objStart.i - objEnd.i) == 2){
                        if (objEnd.i > objStart.i  && matrix[objStart.i + 1][objStart.j].id != "" )
                            return;
                        if (objEnd.i < objStart.i && matrix[objStart.i - 1][objStart.j].id != "" )
                            return;
                    }
                    if (Math.abs(objStart.j - objEnd.j) == 2) {
                        if (objEnd.j > objStart.j && matrix[objStart.i][objStart.j + 1].id != ""  )
                            return;
                        if (objEnd.j < objStart.j && matrix[objStart.i][objStart.j - 1].id != "" )
                            return;
                    }
                    var temp = "do";
                    if(event.currentTarget.id.indexOf(temp) < 0)
                        temp= "den";
                    if (matrix[objEnd.i][objEnd.j].id != "" && matrix[objEnd.i][objEnd.j].id.indexOf(temp) >0)
                        return;
                    
                }
                
               
                var objPara = {};
                objPara.id = event.currentTarget.id;
                objPara.starti = objStart.i;
                objPara.startj = objStart.j;
                objPara.endi = objEnd.i;
                objPara.endj = objEnd.j;
                var objParaList = [];
                objParaList.push(objPara);
                if (matrix[objEnd.i][objEnd.j].id != "") {
                    //document.getElementById(matrix[objEnd.i][objEnd.j].id).style.display = "none";
                    var objRemove = {};
                    objRemove.id = matrix[objEnd.i][objEnd.j].id;
                    objParaList.push(objRemove);
                }
                /*axios.post('/api/Chess/move-chess',
                    JSON.stringify(objParaList), 
                    {
                        headers: {
                            'Content-type': 'application/json',
                        }
                    }).then(response => {
                        console.log('Ok');
                    });
                */
                /*
                var node = document.getElementById(event.currentTarget.id);
                node.style.top = matrix[objEnd.i][objEnd.j].top + 'px';
                node.style.left = matrix[objEnd.i][objEnd.j].left + 'px';
                matrix[objEnd.i][objEnd.j].id = matrix[objStart.i][objStart.j].id;
                matrix[objStart.i][objStart.j].id = "";
                */


            }
            
        },
        // Thay thế mã nguồn SignalR
        mounted: function () {
            this.getChessNode();
        
            // Tạo kết nối WebSocket
            var connection = new WebSocket("ws://localhost:8080/websocket-endpoint");
        
            connection.onmessage = function (event) {
                var message = event.data;
                var objList = JSON.parse(message);
                console.log(objList);
        
                // Xử lý tin nhắn "ChessMove"
                if (objList.action === "ChessMove") {
                    var node = document.getElementById(objList.data[0].id);
                    node.style.top = matrix[objList.data[0].endi][objList.data[0].endj].top + 'px';
                    node.style.left = matrix[objList.data[0].endi][objList.data[0].endj].left + 'px';
        
                    matrix[objList.data[0].endi][objList.data[0].endj].id = node.id;
                    matrix[objList.data[0].starti][objList.data[0].startj].id = "";
        
                    if (objList.data.length === 2) {
                        document.getElementById(objList.data[1].id).style.display = "none";
                    }
                }
            };
        
            connection.onopen = function () {
                console.log("WebSocket connection opened.");
            };
        
            connection.onerror = function (error) {
                console.error("WebSocket error: " + error);
            };
        
            connection.onclose = function () {
                console.log("WebSocket connection closed.");
            };
        }
    });
</script>